// === C++ Libraries ===
#include <algorithm>  // Uses std::max/min when calculating wrap limits and advancing lines.
#include <cctype>     // Applies std::isspace to group characters into words/spaces.
#include <string>     // Holds segments, tokens, and intermediate substrings during drawing.
// === Header Files ===
#include "textLayout.hpp"  // Declares drawColoredSegments implemented below.
#include "helper/colorHelper.hpp"  // Applies special outlines for dark-purple segments.

// Handles word-wrapping and line breaks while drawing each colored segment.
sf::Vector2f drawColoredSegments(
    sf::RenderTarget& target,
    const sf::Font& font,
    const std::vector<ColoredTextSegment>& segments,
    sf::Vector2f startPos,
    unsigned int characterSize,
    float maxWidth,
    float alphaFactor,
    float lineSpacingMultiplier,
    bool measureOnly
) {
    if (segments.empty())
        return startPos;

    const float baseLineStartX = startPos.x;
    const float wrapLimit = baseLineStartX + std::max(0.f, maxWidth);
    sf::Vector2f cursor = startPos;
    sf::Text metrics(font, sf::String(), characterSize);
    metrics.setString("Hg");
    float lineSpacing = metrics.getLineSpacing();
    float baseSpacing = std::max(lineSpacing, static_cast<float>(characterSize));
    const float lineAdvance = baseSpacing * std::max(lineSpacingMultiplier, 1.f);

    for (const auto& segment : segments) {
        if (segment.text.empty())
            continue;

        std::size_t offset = 0;
        // Split segments on explicit newline markers so we can advance lines manually.
        while (offset <= segment.text.size()) {
            std::size_t newlinePos = segment.text.find('\n', offset);
            std::string part = (newlinePos == std::string::npos)
                ? segment.text.substr(offset)
                : segment.text.substr(offset, newlinePos - offset);

            if (!part.empty()) {
                // Prepare an SFML text object tinted by the segment color and alpha factor.
                sf::Text drawable(font, sf::String(), characterSize);
                sf::Color drawableColor = segment.color;
                drawableColor.a = static_cast<std::uint8_t>(static_cast<float>(drawableColor.a) * alphaFactor);
                drawable.setFillColor(drawableColor);
                if (segment.color == ColorHelper::Palette::DarkPurple) {
                    sf::Color outlineColor = sf::Color::White;
                    outlineColor.a = drawableColor.a;
                    drawable.setOutlineColor(outlineColor);
                    drawable.setOutlineThickness(2.f);
                } else {
                    drawable.setOutlineThickness(0.f);
                }

                std::size_t partIndex = 0;
                // Group the substring into runs of spaces or words for proper wrapping.
                while (partIndex < part.size()) {
                    bool isSpace = std::isspace(static_cast<unsigned char>(part[partIndex]));
                    std::string token;

                    // Extend the current run until we hit a different character type.
                    while (partIndex < part.size()) {
                        char c = part[partIndex];
                        bool currentIsSpace = std::isspace(static_cast<unsigned char>(c));
                        if (currentIsSpace != isSpace)
                            break;
                        token.push_back(c);
                        ++partIndex;
                    }

                    if (token.empty())
                        continue;
                    // Skip any empty runs generated by the grouping loop.

                    if (isSpace) {
                        // Spaces are drawn only when we're not at the beginning of a line.
                        drawable.setString(token);
                        float tokenWidth = drawable.getLocalBounds().size.x;

                        // Ignore leading spaces when at the start of a line.
                        if (cursor.x == baseLineStartX)
                            continue;

                        // Wrap to the next line when a space would overflow.
                        if (cursor.x + tokenWidth > wrapLimit) {
                            cursor.x = baseLineStartX;
                            cursor.y += lineAdvance;
                            continue;
                        }

                        // Draw the space and advance the cursor.
                        drawable.setPosition(cursor);
                        if (!measureOnly)
                            target.draw(drawable);
                        cursor.x += tokenWidth;
                    } else {
                        // Handles long words that need to split across multiple lines.
                        auto drawSplitToken = [&](const std::string& word) {
                            std::string currentChunk;

                            // Add one glyph at a time to currentChunk to test fitting.
                            for (char c : word) {
                                std::string nextChunk = currentChunk + c;
                                drawable.setString(nextChunk);
                                float chunkWidth = drawable.getLocalBounds().size.x;

                            // Recompute the remaining horizontal space after any wraps.
                            float availableWidth = wrapLimit - cursor.x;
                                if (availableWidth <= 0.f) {
                                    cursor.x = baseLineStartX;
                                    cursor.y += lineAdvance;
                                    availableWidth = wrapLimit - cursor.x;
                                }

                                // If the current chunk overflows, flush it before continuing.
                                if (chunkWidth > availableWidth && !currentChunk.empty()) {
                                    drawable.setString(currentChunk);
                                    drawable.setPosition(cursor);
                                    if (!measureOnly)
                                        target.draw(drawable);
                                    cursor.x += drawable.getLocalBounds().size.x;
                                    cursor.x = baseLineStartX;
                                    cursor.y += lineAdvance;
                                    currentChunk.clear();
                                    drawable.setString(nextChunk = std::string(1, c));
                                    chunkWidth = drawable.getLocalBounds().size.x;
                                }

                                // Draw single oversized glyphs on their own line when needed.
                                if (cursor.x + chunkWidth > wrapLimit && currentChunk.empty()) {
                                drawable.setPosition(cursor);
                                if (!measureOnly)
                                    target.draw(drawable);
                                cursor.x += chunkWidth;
                                continue;
                            }

                                currentChunk = nextChunk;
                            }

                            // After the loop, render whatever is left in currentChunk.
                            if (!currentChunk.empty()) {
                                drawable.setString(currentChunk);
                                drawable.setPosition(cursor);
                                if (!measureOnly)
                                    target.draw(drawable);
                                cursor.x += drawable.getLocalBounds().size.x;
                            }
                        };

                        // Measure the whole token width for wrapping decisions.
                        drawable.setString(token);
                        float tokenWidth = drawable.getLocalBounds().size.x;

                        // Compute how much horizontal space remains on the line.
                        float availableWidth = wrapLimit - cursor.x;
                        if (availableWidth <= 0.f) {
                            cursor.x = baseLineStartX;
                            cursor.y += lineAdvance;
                            availableWidth = wrapLimit - cursor.x;
                        }

                        // Standard branch: fits on current line.
                        if (tokenWidth <= availableWidth) {
                            drawable.setPosition(cursor);
                            if (!measureOnly)
                                target.draw(drawable);
                            cursor.x += tokenWidth;
                        // Word fits on its own line after we wrap down.
                        } else if (tokenWidth <= maxWidth) {
                            cursor.x = baseLineStartX;
                            cursor.y += lineAdvance;
                            drawable.setPosition(cursor);
                            if (!measureOnly)
                                target.draw(drawable);
                            cursor.x += tokenWidth;
                        // Word is too long even for an empty line; split it.
                        } else {
                            drawSplitToken(token);
                        }
                    }
                }
            }

            // If there are no more explicit newline markers, exit the substring loop.
            if (newlinePos == std::string::npos)
                break;

            // Jump past the newline and move the cursor to the start of the next line.
            offset = newlinePos + 1;
            cursor.x = baseLineStartX;
            cursor.y += lineAdvance;
        }
    }

    return cursor;
}
